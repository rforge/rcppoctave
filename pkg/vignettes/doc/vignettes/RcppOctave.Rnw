\documentclass[10pt,a4paper]{article}
%\VignetteIndexEntry{RcppOctave}

\usepackage{Rd}
\usepackage{Sweave}

\usepackage{xspace}
\usepackage{url}
\usepackage[colorlinks]{hyperref}
\usepackage{a4wide}
\setlength{\oddsidemargin}{0pt}

<<echo=FALSE,print=FALSE>>=
pkg <- 'RcppOctave'
require( pkg, character.only=TRUE )
prettyVersion <- packageDescription(pkg)$Version
pkgtitle <- packageDescription(pkg)$Title
prettyDate <- format(Sys.Date(), "%B %e, %Y")
@

\newcommand{\pkgname}{\texttt{\Sexpr{pkg}}\xspace}
\author{Renaud Gaujoux}
\title{\texttt{\Sexpr{pkg}}: \Sexpr{pkgtitle}}
\date{\texttt{\Sexpr{pkg}} version \Sexpr{prettyVersion} as of \Sexpr{prettyDate}}
\begin{document}
\maketitle

The \pkgname package provides a direct interface to Octave from R.
It allows to call Octave functions in a similar way as calling C/C++/Fortran functions using the R core function~\code{.Call}.
Since Octave uses a language that is mostly compatible with Matlab, the \pkgname package may be used to run Matlab m-files.
As a matter of fact, it was originally developed to facilitates the port and comparison of R and Matlab code.

The package provides modules that port R core random number generators into Octave, that enable to reproduce and compare stochastic computations.
These may also be used in any Octave session, independently of R, increasing the range of RNGs available in Octave.

\section{Sample session}

The \pkgname package provides the function \code{.CallOctave} to call Octave functions:

<<sample_CallOctave>>=
	.CallOctave('eye', 3)
	.CallOctave('svd', matrix(1:9,3))
@

A convenient shortcut interface in defined by the object \code{.O} of class \code{Octave}, exported from \pkgname namespace:

<<sample_CallOctave>>=
	.O$eye(3)
	.O$svd(matrix(1:9,3))
@

Comparing equivalent R and Octave functions is therefore as easy as comparing two R functions.
For example, one can compare the respective functions \code{svd} with the following code: 

<<sample_svd>>=
# define random data
X <- matrix(runif(25), 5)

# run SVD in R
svd.R <- svd(X)
# run SVD in Octave
svd.O <- .O$svd(X)
# check results
svd.O
all.equal(svd.R$d, as.numeric(svd.O))
# but not exactly identical
all.equal(svd.R$d, as.numeric(svd.O), tol=10^-16)
@

We notice here that Octave default \code{svd} returns only the eigen values as a column vector.
This is documented in its documentation that is accessible via the function \code{o\_help}, which will show it in a similar way as R documentation:

<<sample_help, eval=FALSE>>=
# show Octave help for svd
o_help(svd)
@

The documentation for -- Octave -- \code{svd} states that the complete decomposition is returned, if three output values are provided.
This can be done using argument \code{argout}: 

<<svd_complete>>=
# get full output from Octave svd
.O$svd(X, argout=3) 
@
 

\end{document}
